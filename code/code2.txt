>>> srcs

==================
=  check_bltn.c  =
==================
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   check_bltn.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: kadferna <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/21 22:50:20 by kadferna          #+#    #+#             */
/*   Updated: 2025/08/21 22:50:25 by kadferna         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

int	is_builtin(t_command_node *node)
{
	char	*cmd_name;

	if (!node || !node->argv || !node->argv[0])
		return (0);
	cmd_name = node->argv[0];
	if (ft_strncmp(cmd_name, "echo", ft_strlen(cmd_name) + 1) == 0)
		return (1);
	if (ft_strncmp(cmd_name, "cd", ft_strlen(cmd_name) + 1) == 0)
		return (2);
	if (ft_strncmp(cmd_name, "pwd", ft_strlen(cmd_name) + 1) == 0)
		return (3);
	if (ft_strncmp(cmd_name, "export", ft_strlen(cmd_name) + 1) == 0)
		return (4);
	if (ft_strncmp(cmd_name, "unset", ft_strlen(cmd_name) + 1) == 0)
		return (5);
	if (ft_strncmp(cmd_name, "env", ft_strlen(cmd_name) + 1) == 0)
		return (6);
	if (ft_strncmp(cmd_name, "exit", ft_strlen(cmd_name) + 1) == 0)
		return (7);
	return (0);
}

==============
=  closes.c  =
==============
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   closes.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: kadferna <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/18 20:44:15 by kadferna          #+#    #+#             */
/*   Updated: 2025/08/18 20:44:18 by kadferna         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

void	close2_fd(int fd1, int fd2)
{
	close(fd1);
	close(fd2);
}

void	perror_exit(char *msg, int i)
{
	perror(msg);
	exit(i);
}

==============
=  utils0.c  =
==============
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils0.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: kadferna <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/12 17:32:34 by kadferna          #+#    #+#             */
/*   Updated: 2025/09/10 14:41:48 by anjbaiju         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

void	ft_exit(char *r1, t_token *token, char **envp_ptr, t_ast_node *pipe)
{
	printf("exit\n");
	if (envp_ptr != NULL)
		free_environment(envp_ptr);
	if (token)
		free_token(token);
	if (pipe)
		free_ast(pipe);
	if (r1)
		free(r1);
}

int	is_single_quoted(const char *str)
{
	int	i;

	i = 0;
	if (str[i] == '\'' && str[strlen(str) - 1] == '\'')
		return (1);
	return (0);
}

void	*ft_realloc(void *a, size_t old_size, size_t new_size)
{
	void	*new_ptr;
	size_t	copy_size;

	if (!new_size)
	{
		free(a);
		return (NULL);
	}
	new_ptr = malloc(new_size);
	if (!new_ptr)
		return (NULL);
	if (a)
	{
		if (old_size < new_size)
			copy_size = old_size;
		else
			copy_size = new_size;
		ft_memcpy(new_ptr, a, copy_size);
		free(a);
	}
	return (new_ptr);
}

int	get_array_len(char **tokens)
{
	int	i;

	i = 0;
	if (!tokens)
		return (i);
	while (tokens[i] != NULL)
		i++;
	return (i);
}

==============
=  utils1.c  =
==============
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils1.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: kadferna <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/16 23:04:29 by kadferna          #+#    #+#             */
/*   Updated: 2025/09/16 23:04:36 by kadferna         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../minishell.h"

char	**copy_environment(char *envp[])
{
	int		count;
	char	**new_envp;
	int		i;

	count = 0;
	while (envp[count])
		count++;
	new_envp = (char **)malloc(sizeof(char *) * (count + 1));
	if (!new_envp)
		return (NULL);
	i = 0;
	while (i < count)
	{
		new_envp[i] = ft_strdup(envp[i]);
		if (!new_envp[i])
			return (free_til(new_envp, i), NULL);
		i++;
	}
	new_envp[count] = NULL;
	return (new_envp);
}

int	ft_strcmp(const char *s1, const char *s2)
{
	size_t	i;

	i = 0;
	while (s1[i] && s2[i] && s1[i] == s2[i])
		i++;
	return ((unsigned char)s1[i] - (unsigned char)s2[i]);
}

char	*ft_strcpy(char *dest, const char *src)
{
	int	i;

	i = 0;
	while (src[i] != '\0')
	{
		dest[i] = src[i];
		i++;
	}
	dest[i] = '\0';
	return (dest);
}

char	*ft_strstr(const char *haystack, const char *needle)
{
	size_t	i;
	size_t	j;

	if (*needle == '\0')
		return ((char *)haystack);
	i = 0;
	while (haystack[i] != '\0')
	{
		j = 0;
		while (haystack[i + j] != '\0' && needle[j] != '\0' && haystack[i
				+ j] == needle[j])
		{
			j++;
		}
		if (needle[j] == '\0')
		{
			return ((char *)&haystack[i]);
		}
		i++;
	}
	return (NULL);
}

>>> bltn_funcs/


>>> errors/

======================
=  errors/errors1.c  =
======================
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   errors1.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: kadferna <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/21 19:20:51 by kadferna          #+#    #+#             */
/*   Updated: 2025/08/21 19:20:53 by kadferna         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../minishell.h"

void	std_err_msg(char *msg)
{
	printf("Error\n %s\n", msg);
}

void	report_syntax_error(char *msg, t_token *token)
{
	printf("%s: %s\n", msg, token->value);
}

=====================
=  errors/errors.c  =
=====================
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   errors.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: kadferna <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/31 10:42:06 by kadferna          #+#    #+#             */
/*   Updated: 2025/07/31 10:42:07 by kadferna         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../minishell.h"

int	perror_ret(char *msg, int i)
{
	perror(msg);
	return (i);
}

void	command_not_found(t_command_node *cmd)
{
	write(2, "minishell: ", 11);
	write(2, cmd->argv[0], ft_strlen(cmd->argv[0]));
	write(2, ": command not found\n", 20);
}

void	execve_error(t_command_node *cmd)
{
	write(2, "minishell: ", 11);
	write(2, cmd->argv[0], ft_strlen(cmd->argv[0]));
	write(2, strerror(errno), ft_strlen(strerror(errno)));
	write(2, "\n", ft_strlen("\n"));
}

void	printf_err(char *msg, t_node_type type)
{
	write(2, msg, ft_strlen(msg));
	write(2, " - Type: ", 9);
	ft_putnbr_fd(type, 2);
	write(2, "\n", 1);
}


>>> exec/

==========================
=  exec/exec_builtins.c  =
==========================
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exec_builtins.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: kadferna <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/03 11:03:36 by kadferna          #+#    #+#             */
/*   Updated: 2025/09/03 11:04:45 by kadferna         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../minishell.h"

int	execute_builtin(t_command_node *cmd, char ***envp, t_ast_node *pipe)
{
	char	*cmd_name;

	cmd_name = cmd->argv[0];
	if (ft_strncmp(cmd_name, "echo", ft_strlen(cmd_name)) == 0)
		return (ft_echo(cmd->argv));
	if (ft_strncmp(cmd_name, "cd", ft_strlen(cmd_name)) == 0)
		return (ft_cd(cmd->argv, envp));
	if (ft_strncmp(cmd_name, "pwd", ft_strlen(cmd_name)) == 0)
		return (ft_pwd());
	if (ft_strncmp(cmd_name, "export", ft_strlen(cmd_name)) == 0)
		return (ft_export(cmd->argv, envp));
	if (ft_strncmp(cmd_name, "unset", ft_strlen(cmd_name)) == 0)
		return (ft_unset(cmd->argv, envp));
	if (ft_strncmp(cmd_name, "env", ft_strlen(cmd_name)) == 0)
		return (ft_env(*envp));
	if (ft_strncmp(cmd_name, "exit", ft_strlen(cmd_name)) == 0)
		return (ft_exit_builtin(*envp, pipe, cmd, 0));
	return (0);
}

=================
=  exec/exec.c  =
=================
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exec.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: kadferna <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/25 11:06:46 by kadferna          #+#    #+#             */
/*   Updated: 2025/07/25 11:06:47 by kadferna         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../minishell.h"

int	execute_ast_pipeline(t_ast_node *node, char ***envp_ptr)
{
	int	result;

	if (!node)
		return (0);
	result = exec_ast(node, envp_ptr, node);
	free_ast(node);
	return (result);
}

int	exec_ast(t_ast_node *node, char ***envp, t_ast_node *root_node)
{
	if (node->type == NODE_COMMAND)
	{
		return (exec_simple_command((t_command_node *)node, envp, root_node));
	}
	if (node->type == NODE_PIPE)
		return (exec_pipe_node((t_pipe_node *)node, envp, root_node));
	printf_err("minishell: Unrecognized node type", node->type);
	return (127);
}

int	exec_blt_command(t_command_node *cmd, char ***envp, t_ast_node *node)
{
	int	stdout_backup;
	int	stdin_backup;
	int	result;

	stdout_backup = dup(STDOUT_FILENO);
	stdin_backup = dup(STDIN_FILENO);
	errno = 0;
	handle_redirections(cmd->redirections);
	if (errno != 0)
	{
		dup2(stdout_backup, STDOUT_FILENO);
		dup2(stdin_backup, STDIN_FILENO);
		close(stdout_backup);
		close(stdin_backup);
		return (1);
	}
	result = execute_builtin(cmd, envp, node);
	dup2(stdout_backup, STDOUT_FILENO);
	dup2(stdin_backup, STDIN_FILENO);
	close(stdout_backup);
	close(stdin_backup);
	return (result);
}

int	exec_simple_command(t_command_node *cmd, char ***envp,
		t_ast_node *root_node)
{
	pid_t	pid;
	int		status;
	char	*cmd_path;
	int		builtin_type;

	builtin_type = is_builtin(cmd);
	cmd_path = NULL;
	if (builtin_type > 0)
		return (exec_blt_command(cmd, envp, root_node));
	pid = fork();
	if (pid == -1)
		return (perror_ret("fork", 1));
	if (pid == 0)
	{
		handle_cmd_path(&cmd_path, cmd, envp, root_node);
		free(cmd_path);
		exit(126);
	}
	waitpid(pid, &status, 0);
	if (WIFEXITED(status))
		return (WEXITSTATUS(status));
	return (128 + WTERMSIG(status));
}

int	exec_pipe_node(t_pipe_node *pipe_node, char ***envp, t_ast_node *root_node)
{
	int		fd[2];
	pid_t	pid_left;
	pid_t	pid_right;
	int		status_right;

	if (pipe(fd) == -1)
		return (perror_ret("pipe", 1));
	pid_left = fork();
	if (pid_left == -1)
		return (perror_ret("fork", 1));
	if (pid_left == 0)
		handle_left_child(fd, pipe_node->left, *envp, root_node);
	pid_right = fork();
	if (pid_right == -1)
		return (perror_ret("fork", 1));
	if (pid_right == 0)
		handle_right_child(fd, pipe_node->right, *envp, root_node);
	close2_fd(fd[0], fd[1]);
	waitpid(pid_left, NULL, 0);
	waitpid(pid_right, &status_right, 0);
	if (WIFEXITED(status_right))
		return (WEXITSTATUS(status_right));
	return (128 + WTERMSIG(status_right));
}

========================
=  exec/exec_utils1.c  =
========================
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exec_utils1.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: kadferna <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/16 22:03:48 by kadferna          #+#    #+#             */
/*   Updated: 2025/09/20 00:55:32 by kadferna         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../minishell.h"

void	handle_cmd_path(char **cmd_path, t_command_node *cmd, char ***envp,
		t_ast_node *node)
{
	handle_redirections(cmd->redirections);
	*cmd_path = resolve_command_path(cmd->argv[0], *envp);
	if (!*cmd_path)
	{
		command_not_found(cmd);
		ft_exit_nomsg(*envp, node, 127);
	}
	execve(*cmd_path, cmd->argv, *envp);
	execve_error(cmd);
}

static int	open_input_file(t_redirect *redir)
{
	int	fd;

	if (!redir || !redir->filename)
		return (-1);
	fd = open(redir->filename, O_RDONLY);
	if (fd == -1)
	{
		if (redir->type == REDIR_HEREDOC)
			perror_exit("heredoc temp file", 1);
		else
			perror_exit(redir->filename, 1);
	}
	return (fd);
}

static int	open_output_file(t_redirect *redir)
{
	int	fd;
	int	flags;

	flags = O_WRONLY | O_CREAT;
	if (!redir || !redir->filename)
		return (-1);
	if (redir->type == REDIR_OUT)
		flags |= O_TRUNC;
	else if (redir->type == REDIR_APPEND)
		flags |= O_APPEND;
	fd = open(redir->filename, flags, 0644);
	if (fd == -1)
		perror_exit(redir->filename, 1);
	return (fd);
}

int	open_file_based_on_type(t_redirect *redir)
{
	if (!redir || !redir->filename)
		return (-1);
	if (redir->type == REDIR_IN || redir->type == REDIR_HEREDOC)
		return (open_input_file(redir));
	else if (redir->type == REDIR_OUT || redir->type == REDIR_APPEND)
		return (open_output_file(redir));
	return (-1);
}

void	handle_redirections(t_redirect *redirections)
{
	int	fd_table[10];
	int	target_fd;
	int	new_fd;
	int	i;

	i = -1;
	while (++i < 10)
		fd_table[i] = -1;
	while (redirections)
	{
		if (redirections->type == REDIR_IN)
			target_fd = 0;
		else if (redirections->type == REDIR_OUT
			|| redirections->type == REDIR_APPEND)
			target_fd = 1;
		if (fd_table[target_fd] != -1)
		{
			close(fd_table[target_fd]);
			fd_table[target_fd] = -1;
		}
		new_fd = open_file_based_on_type(redirections);
		dup2(new_fd, target_fd);
		fd_table[target_fd] = new_fd;
		redirections = redirections->next;
	}
}

=======================
=  exec/exec_utils.c  =
=======================
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exec_utils.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: kadferna <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/05 17:11:49 by kadferna          #+#    #+#             */
/*   Updated: 2025/08/05 17:11:52 by kadferna         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../minishell.h"

char	*process_path(char **paths, const char *cmd_name)
{
	int		i;
	char	*tmp;
	char	*full_path;

	i = 0;
	while (paths[i])
	{
		tmp = ft_strjoin(paths[i], "/");
		full_path = ft_strjoin(tmp, cmd_name);
		free(tmp);
		if (access(full_path, X_OK) == 0)
		{
			free_paths(paths);
			return (full_path);
		}
		free(full_path);
		i++;
	}
	return (NULL);
}

char	*resolve_command_path(const char *cmd_name, char **envp)
{
	char	**paths;
	char	*full_path;

	if (!cmd_name || !*cmd_name)
		return (NULL);
	if (ft_strchr(cmd_name, '/'))
	{
		if (access(cmd_name, X_OK) == 0)
			return (ft_strdup(cmd_name));
		return (NULL);
	}
	paths = get_path(envp);
	if (!paths)
		return (NULL);
	full_path = process_path(paths, cmd_name);
	if (full_path != NULL)
		return (full_path);
	free_paths(paths);
	return (NULL);
}

void	handle_left_child(int *pipe_fd, t_ast_node *node, char **envp,
		t_ast_node *root_node)
{
	int	exit_code;

	close(pipe_fd[0]);
	if (dup2(pipe_fd[1], STDOUT_FILENO) == -1)
	{
		perror("dup2");
		free_ast(root_node);
		free_environment(envp);
		exit(EXIT_FAILURE);
	}
	close(pipe_fd[1]);
	exit_code = exec_ast(node, &envp, root_node);
	free_ast(root_node);
	free_environment(envp);
	exit(exit_code);
}

void	handle_right_child(int *pipe_fd, t_ast_node *node, char **envp,
		t_ast_node *root_node)
{
	int	exit_code;

	close(pipe_fd[1]);
	if (dup2(pipe_fd[0], STDIN_FILENO) == -1)
	{
		perror("dup2");
		free_ast(root_node);
		free_environment(envp);
		exit(EXIT_FAILURE);
	}
	close(pipe_fd[0]);
	exit_code = exec_ast(node, &envp, root_node);
	free_ast(root_node);
	free_environment(envp);
	exit(exit_code);
}

char	**get_path(char *env[])
{
	char	**paths;
	char	*path_env;

	path_env = NULL;
	while (*env)
	{
		if (ft_strncmp(*env, "PATH=", 5) == 0)
		{
			path_env = *env;
			break ;
		}
		env++;
	}
	if (!path_env)
		return (NULL);
	paths = ft_split(path_env + 5, ':');
	return (paths);
}


>>> free/

===================
=  free/frees1.c  =
===================
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   frees1.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: kadferna <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/16 22:30:24 by kadferna          #+#    #+#             */
/*   Updated: 2025/09/16 22:30:27 by kadferna         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../minishell.h"

void	free_environment(char **msh_envp)
{
	int	i;

	if (!msh_envp)
		return ;
	i = 0;
	while (msh_envp[i])
	{
		free(msh_envp[i]);
		i++;
	}
	free(msh_envp);
}

void	free_tokens_array(char **tokens)
{
	int	i;

	if ((!tokens) || !(*tokens))
		return ;
	i = 0;
	while (tokens[i])
	{
		free(tokens[i]);
		i++;
	}
	free(tokens);
}

void	free_on_exiting_list(t_token *tokens)
{
	t_token	*current;
	t_token	*next;

	if (!tokens)
		return ;
	current = tokens;
	while (current != NULL)
	{
		next = current->next;
		if (current->value != NULL)
			free(current->value);
		free(current);
		current = next;
	}
}

void	free_paths(char **paths)
{
	int	i;

	if (!paths)
		return ;
	i = 0;
	while (paths[i])
	{
		free(paths[i]);
		i++;
	}
	free(paths);
}

void	free_pipe(t_ast_node *node)
{
	t_pipe_node	*pipe;

	pipe = (t_pipe_node *)node;
	if (pipe->left)
	{
		free_ast(pipe->left);
		pipe->left = NULL;
	}
	if (pipe->right)
	{
		free_ast(pipe->right);
		pipe->right = NULL;
	}
	free(pipe);
}

===================
=  free/frees2.c  =
===================
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   frees2.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: kadferna <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/17 11:16:56 by kadferna          #+#    #+#             */
/*   Updated: 2025/09/17 11:17:01 by kadferna         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../minishell.h"

void	free_ast(t_ast_node *node)
{
	int				i;
	t_command_node	*cmd;

	if (!node)
		return ;
	if (node->type == NODE_COMMAND)
	{
		cmd = (t_command_node *)node;
		if (cmd->argv)
		{
			i = -1;
			while (cmd->argv[++i])
			{
				free(cmd->argv[i]);
				cmd->argv[i] = NULL;
			}
			free(cmd->argv);
			cmd->argv = NULL;
		}
		free_redirects(cmd->redirections);
		cmd->redirections = NULL;
		free(cmd);
	}
	else if (node->type == NODE_PIPE)
		free_pipe(node);
}

void	free_til(char **tokens, int i)
{
	if ((!tokens) || !(*tokens))
		return ;
	while (i > 0)
	{
		i--;
		free(tokens[i]);
	}
	free(tokens);
}

==================
=  free/frees.c  =
==================
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   frees.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: kadferna <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/14 10:31:48 by kadferna          #+#    #+#             */
/*   Updated: 2025/09/19 15:19:16 by anjbaiju         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../minishell.h"

void	free_r1(char *r1)
{
	if (r1 == NULL)
		return ;
	free(r1);
}

int	free_on_error(char **result, int word_count)
{
	while (word_count > 0)
	{
		word_count--;
		free(result[word_count]);
	}
	return (0);
}

void	free_token(t_token *token)
{
	t_token	*current;
	t_token	*next;

	current = token;
	while (current != NULL)
	{
		next = current->next;
		if (current->value != NULL)
			free(current->value);
		free(current);
		current = next;
	}
}

void	free_tokens(char **tokens)
{
	int	i;

	if (!tokens)
		return ;
	i = 0;
	while (tokens[i] != NULL)
	{
		free(tokens[i]);
		i++;
	}
	free(tokens);
	tokens = NULL;
}

void	free_redirects(t_redirect *redir)
{
	t_redirect	*curr;
	t_redirect	*next;

	curr = redir;
	while (curr)
	{
		next = curr->next;
		free(curr->filename);
		free(curr);
		curr = next;
	}
}


>>> lexer/

========================
=  lexer/free_lexer.c  =
========================
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   free_lexer.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: kadferna <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/28 11:40:07 by kadferna          #+#    #+#             */
/*   Updated: 2025/07/28 11:40:08 by kadferna         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../minishell.h"

t_redirect	*create_redirect(t_redirect_type type, char *filename)
{
	t_redirect	*new;

	new = malloc(sizeof(t_redirect));
	if (!new)
		return (NULL);
	new->type = type;
	new->filename = ft_strdup(filename);
	new->next = NULL;
	return (new);
}

void	add_redirect(t_redirect **list, t_redirect *new)
{
	t_redirect	*curr;

	if (!*list)
	{
		*list = new;
		return ;
	}
	curr = *list;
	while (curr->next)
		curr = curr->next;
	curr->next = new;
}

===================
=  lexer/lexer.c  =
===================
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   lexer.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: kadferna <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/23 13:22:02 by kadferna          #+#    #+#             */
/*   Updated: 2025/07/23 13:22:04 by kadferna         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../minishell.h"

char	**construct_tokens(char *line)
{
	char		**tokens;
	int			word_count;
	int			i;
	const char	*line_ptr;

	if (!line)
		return (NULL);
	line_ptr = line;
	word_count = count_words_shell(line_ptr);
	tokens = malloc(sizeof(char *) * (word_count + 1));
	if (!tokens)
		return (NULL);
	i = 0;
	line_ptr = line;
	while (i < word_count)
	{
		tokens[i] = get_next_word(&line_ptr);
		if (!tokens[i])
			return (free_til(tokens, i), NULL);
		i++;
	}
	tokens[i] = NULL;
	return (tokens);
}

t_token	*get_tokens(char **tokens)
{
	t_token	*head;
	t_token	*current;
	t_token	*new;
	int		i;

	if (!tokens || !tokens[0])
		return (NULL);
	head = NULL;
	current = NULL;
	i = 0;
	while (tokens[i] != NULL)
	{
		new = handle_new(head, i, tokens);
		if (!new)
			return (NULL);
		if (!head)
			head = new;
		else
			current->next = new;
		current = new;
		i++;
	}
	specify_tokens(head);
	return (head);
}

t_token	*init_tokens(char *line)
{
	char	**tokens;
	t_token	*token;
	int		i;

	tokens = construct_tokens(line);
	if (!tokens)
		return (NULL);
	token = get_tokens(tokens);
	if (tokens)
	{
		i = 0;
		while (tokens[i])
		{
			free(tokens[i]);
			i++;
		}
		free(tokens);
	}
	if (!token)
		return (NULL);
	return (token);
}

==========================
=  lexer/lexer_utils1.c  =
==========================
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   lexer_utils1.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: kadferna <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/19 16:46:06 by anjbaiju          #+#    #+#             */
/*   Updated: 2025/09/19 16:49:46 by anjbaiju         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../minishell.h"

void	skip_whitespace(const char *s, int *i)
{
	while (s[*i] && (s[*i] == ' ' || s[*i] == '\t' || s[*i] == '\n'
			|| s[*i] == '\v' || s[*i] == '\f' || s[*i] == '\r'))
		(*i)++;
}

int	count_redir_or_pipe(const char *s, int *i)
{
	int	c;

	c = 0;
	if (s[*i] == '<' || s[*i] == '>')
	{
		c++;
		if (s[*i + 1] && s[*i + 1] == s[*i])
			(*i)++;
		(*i)++;
	}
	else if (s[*i] == '|')
	{
		c++;
		(*i)++;
	}
	return (c);
}

char	*handle_redir_pipe(const char *s, int *i)
{
	const char	*start = s + *i;
	int			len;
	char		*word;

	len = 1;
	if (s[*i] == '<' || s[*i] == '>')
	{
		if (s[*i + 1] && s[*i + 1] == s[*i])
			len = 2;
	}
	else if (s[*i] == '|')
		len = 1;
	else
		return (NULL);
	word = malloc(sizeof(char) * (len + 1));
	if (!word)
		return (NULL);
	ft_strlcpy(word, start, len + 1);
	*i += len;
	return (word);
}

int	count_word_token(const char *s, int *i, char *quote)
{
	int	started;

	started = 0;
	if (s[*i])
	{
		started = 1;
		while (s[*i] && ((s[*i] != ' ' && s[*i] != '\t' && s[*i] != '\n'
					&& s[*i] != '\v' && s[*i] != '\f' && s[*i] != '\r'
					&& s[*i] != '<' && s[*i] != '>' && s[*i] != '|') || *quote))
		{
			if (!*quote && (s[*i] == '\'' || s[*i] == '"'))
				*quote = s[*i];
			else if (*quote == s[*i])
				*quote = 0;
			(*i)++;
		}
	}
	return (started);
}

char	*extract_word_token(const char *s, int *i)
{
	const char	*start = s + *i;
	int			len;
	char		quote;
	char		*word;

	len = 0;
	quote = 0;
	while (s[*i] && ((!is_separator(s[*i])) || quote))
	{
		if (!quote && (s[*i] == '\'' || s[*i] == '"'))
			quote = s[*i];
		else if (quote == s[*i])
			quote = 0;
		(*i)++;
		len++;
	}
	word = malloc(sizeof(char) * (len + 1));
	if (!word)
		return (NULL);
	ft_strlcpy(word, start, len + 1);
	return (word);
}

=========================
=  lexer/lexer_utils.c  =
=========================
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   lexer_utils.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: kadferna <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/28 11:15:22 by kadferna          #+#    #+#             */
/*   Updated: 2025/09/19 16:45:52 by anjbaiju         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../minishell.h"

int	is_separator(char c)
{
	return (c == ' ' || c == '\t' || c == '\n' || c == '\v' || c == '\f'
		|| c == '\r' || c == '<' || c == '>' || c == '|');
}

int	count_words_shell(const char *s)
{
	int		i;
	int		count;
	char	quote_state;

	i = 0;
	count = 0;
	quote_state = 0;
	while (s[i])
	{
		skip_whitespace(s, &i);
		if (s[i] == '<' || s[i] == '>' || s[i] == '|')
			count += count_redir_or_pipe(s, &i);
		else if (s[i])
			count += count_word_token(s, &i, &quote_state);
	}
	return (count);
}

char	*get_next_word(const char **s)
{
	int		i;
	char	*word;

	i = 0;
	skip_whitespace(*s, &i);
	word = handle_redir_pipe(*s, &i);
	if (word)
	{
		*s += i;
		return (word);
	}
	word = extract_word_token(*s, &i);
	*s += i;
	return (word);
}

void	specify_tokens(t_token *token)
{
	t_token	*current;

	current = token;
	while (current != NULL)
	{
		if (ft_strncmp(current->value, "|", 2) == 0)
			current->type = TOKEN_PIPE;
		else if (ft_strncmp(current->value, "<", 2) == 0)
			current->type = TOKEN_REDIR_IN;
		else if (ft_strncmp(current->value, ">", 2) == 0)
			current->type = TOKEN_REDIR_OUT;
		else if (ft_strncmp(current->value, "<<", 3) == 0)
			current->type = TOKEN_HEREDOC;
		else if (ft_strncmp(current->value, ">>", 3) == 0)
			current->type = TOKEN_REDIR_APPEND;
		else
			current->type = TOKEN_WORD;
		current = current->next;
	}
}

t_token	*handle_new(t_token *head, int i, char **tokens)
{
	t_token	*new;

	new = malloc(sizeof(t_token));
	if (!new)
		return (free_token(head), NULL);
	new->value = ft_strdup(tokens[i]);
	if (!new->value)
		return (free(new), free_token(head), NULL);
	new->next = NULL;
	new->type = TOKEN_WORD;
	return (new);
}


>>> parsing/

============================
=  parsing/parse_helper.c  =
============================
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse_helper.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: kadferna <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/31 12:01:39 by kadferna          #+#    #+#             */
/*   Updated: 2025/07/31 12:01:41 by kadferna         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../minishell.h"

t_redirect	*create_redirect_node(t_redirect_type type, char *filename)
{
	t_redirect	*new;

	new = malloc(sizeof(t_redirect));
	if (!new)
		return (NULL);
	new->type = type;
	new->filename = strdup(filename);
	new->next = NULL;
	return (new);
}

char	**list_to_array(t_list *lst)
{
	char	**array;
	int		len;
	int		i;
	t_list	*tmp;

	if (!lst)
		return (NULL);
	len = 0;
	tmp = lst;
	while (tmp)
	{
		len++;
		tmp = tmp->next;
	}
	array = malloc(sizeof(char *) * (len + 1));
	if (!array)
		return (NULL);
	i = 0;
	tmp = lst;
	if (!put_content(tmp, array, &i))
		return (NULL);
	array[i] = NULL;
	return (array);
}

============================
=  parsing/parse_utils1.c  =
============================
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse_utils1.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anjbaiju <anjbaiju@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/19 16:36:48 by anjbaiju          #+#    #+#             */
/*   Updated: 2025/09/19 16:36:49 by anjbaiju         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../minishell.h"

t_command_node	*init_command_node(void)
{
	t_command_node	*cmd;

	cmd = malloc(sizeof(t_command_node));
	if (!cmd)
		return (NULL);
	cmd->type = NODE_COMMAND;
	cmd->argv = NULL;
	cmd->redirections = NULL;
	return (cmd);
}

bool	handle_redirection(t_token **token, t_list **words, t_redirect **redirs)
{
	t_redirect	*new_redir;

	new_redir = parse_redirections(token);
	if (!new_redir)
	{
		ft_lstclear(words, free);
		free_redirects(*redirs);
		return (false);
	}
	add_redirect(redirs, new_redir);
	return (true);
}

bool	process_command_tokens(t_token **token, t_list **words,
		t_redirect **redirs)
{
	while (*token && (*token)->type != TOKEN_PIPE)
	{
		if (is_redirection(*token))
		{
			if (!handle_redirection(token, words, redirs))
				return (false);
		}
		else if ((*token)->type == TOKEN_WORD)
		{
			ft_lstadd_back(words, ft_lstnew(ft_strdup((*token)->value)));
			advance_token(token);
		}
		else
		{
			ft_putstr_fd("minishell: syntax error: unexpected token\n", 2);
			ft_lstclear(words, free);
			free_redirects(*redirs);
			return (false);
		}
	}
	return (true);
}

===========================
=  parsing/parse_utils.c  =
===========================
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse_utils.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: kadferna <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/31 11:14:42 by kadferna          #+#    #+#             */
/*   Updated: 2025/07/31 11:14:44 by kadferna         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../minishell.h"

void	advance_token(t_token **token)
{
	if (*token && (*token)->next)
		*token = (*token)->next;
	else
		*token = NULL;
}

t_pipe_node	*create_pipe_node(t_ast_node *left, t_ast_node *right)
{
	t_pipe_node	*node;

	node = malloc(sizeof(t_pipe_node));
	if (!node)
		return (NULL);
	node->type = NODE_PIPE;
	node->left = left;
	node->right = right;
	return (node);
}

t_redirect_type	get_redir_type(t_tokentype token_type)
{
	if (token_type == TOKEN_REDIR_IN)
		return (REDIR_IN);
	else if (token_type == TOKEN_REDIR_OUT)
		return (REDIR_OUT);
	else if (token_type == TOKEN_REDIR_APPEND)
		return (REDIR_APPEND);
	else if (token_type == TOKEN_HEREDOC)
		return (REDIR_HEREDOC);
	return (REDIR_NONE);
}

bool	is_redirection(t_token *token)
{
	if (!token)
		return (false);
	return (token->type == TOKEN_REDIR_IN || token->type == TOKEN_REDIR_OUT
		|| token->type == TOKEN_REDIR_APPEND || token->type == TOKEN_HEREDOC);
}

int	put_content(t_list *tmp, char **array, int *i)
{
	while (tmp)
	{
		array[*i] = ft_strdup((char *)tmp->content);
		if (!array[*i])
		{
			while (*i > 0)
			{
				(*i)--;
				free(array[*i]);
			}
			return (0);
		}
		(*i)++;
		tmp = tmp->next;
	}
	return (1);
}

=======================
=  parsing/parsing.c  =
=======================
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parsing.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: kadferna <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/16 16:50:34 by kadferna          #+#    #+#             */
/*   Updated: 2025/09/20 00:10:03 by kadferna         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../minishell.h"

t_redirect	*parse_redirections(t_token **token)
{
	t_redirect		*redir;
	t_redirect_type	type;

	type = get_redir_type((*token)->type);
	advance_token(token);
	if (!*token || (*token)->type != TOKEN_WORD)
	{
		ft_putstr_fd("minishell: syntax error near unexpected token\n", 2);
		return (NULL);
	}
	redir = create_redirect(type, (*token)->value);
	advance_token(token);
	return (redir);
}

t_ast_node	*parse_cmds(t_token **token)
{
	t_command_node	*cmd;
	t_list			*words;
	t_redirect		*redirs;

	words = NULL;
	redirs = NULL;
	cmd = init_command_node();
	if (!cmd)
		return (NULL);
	if (!process_command_tokens(token, &words, &redirs))
	{
		free(cmd);
		return (NULL);
	}
	if (words)
	{
		cmd->argv = list_to_array(words);
		ft_lstclear(&words, free);
	}
	cmd->redirections = redirs;
	return ((t_ast_node *)cmd);
}

t_ast_node	*parse_pipe(t_token **token)
{
	t_ast_node	*node;
	t_ast_node	*right;

	node = parse_cmds(token);
	if (!node)
		return (NULL);
	while (*token && (*token)->type == TOKEN_PIPE)
	{
		advance_token(token);
		if (!*token)
		{
			ft_putstr_fd("minishell: syntax error near unexpected token `|'\n",
				2);
			free_ast(node);
			return (NULL);
		}
		right = parse_cmds(token);
		if (!right)
		{
			free_ast(node);
			return (NULL);
		}
		node = (t_ast_node *)create_pipe_node(node, right);
	}
	return (node);
}

t_ast_node	*parse(t_token *token)
{
	t_token		*current;
	t_ast_node	*ast;

	current = token;
	if (!current)
		return (NULL);
	ast = parse_pipe(&current);
	if (current != NULL)
	{
		ft_putstr_fd("minishell: syntax error: ", 2);
		ft_putstr_fd("unexpected token at end of command\n", 2);
		free_ast(ast);
		return (NULL);
	}
	return (ast);
}


>>> shell/

======================
=  shell/ft_shell.c  =
======================
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_shell.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: kadferna <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/16 23:11:22 by kadferna          #+#    #+#             */
/*   Updated: 2025/09/16 23:11:24 by kadferna         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../minishell.h"

void	initialize_shell(t_shell_state *state, char *envp[])
{
	struct sigaction	sa;

	state->exit_code = 0;
	state->pipe = NULL;
	save_terminal_state(&state->original_term);
	state->envp_copy = copy_environment(envp);
	if (!process_signals(&sa))
		exit(1);
}

void	process_line(char *line, t_shell_state *state)
{
	t_token	*token;

	if (!validate_quotes(line))
	{
		free(line);
		return ;
	}
	if (*line)
	{
		add_history(line);
		token = init_tokens(line);
		expand_token_variables(token, state->exit_code, &state->envp_copy);
		state->pipe = parse(token);
		free_token(token);
		if (state->pipe)
		{
			state->temp_exit = execute_ast_pipeline(state->pipe,
					&state->envp_copy);
			state->exit_code = state->temp_exit;
			state->pipe = NULL;
		}
	}
	free(line);
}

void	shell_loop(t_shell_state *state)
{
	char	*line;

	while (1)
	{
		if (g_signal_received)
			g_signal_received = 0;
		line = readline("minishell$ ");
		if (line == NULL)
		{
			cleanup_shell(state);
			ft_exit(line, NULL, NULL, NULL);
			exit(state->exit_code);
		}
		process_line(line, state);
	}
}

void	cleanup_shell(t_shell_state *state)
{
	restore_terminal_state(&state->original_term);
	if (state->envp_copy)
		free_environment(state->envp_copy);
	state->envp_copy = NULL;
	if (state->pipe)
		free_ast(state->pipe);
	state->pipe = NULL;
	clear_history();
}


>>> signals/

=======================
=  signals/signals.c  =
=======================
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   signals.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: kadferna <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/14 11:03:24 by kadferna          #+#    #+#             */
/*   Updated: 2025/07/14 14:44:05 by kadferna         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../minishell.h"

void	signal_handler(int sig)
{
	if (sig == SIGINT)
	{
		g_signal_received = 1;
		write(STDOUT_FILENO, "\n", 1);
		rl_on_new_line();
		rl_replace_line("", 0);
		rl_redisplay();
	}
}

int	process_signals(struct sigaction *sa)
{
	sa->sa_handler = signal_handler;
	sigemptyset(&sa->sa_mask);
	sa->sa_flags = 0;
	if (sigaction(SIGINT, sa, NULL) == -1)
	{
		perror("sigaction");
		return (0);
	}
	signal(SIGQUIT, SIG_IGN);
	return (1);
}

void	save_terminal_state(struct termios *original_state)
{
	tcgetattr(STDIN_FILENO, original_state);
}

void	restore_terminal_state(struct termios *original_state)
{
	tcsetattr(STDIN_FILENO, TCSANOW, original_state);
}


